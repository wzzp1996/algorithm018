学习笔记
HashMap
 dk8
 1、HashMap的源码
 内部维护字段：
 DEFAULT_INITIAL_CAPACITY   初始化容量   1 << 4  = 16
 啥非得是2的幂次方 ，2的倍数不行么，奇数不行么？
 答：如果为奇数，那么计算在计算hash冲突过程中，（n-1）&hash 的值尾数一定为0，那样冲突的可能性更大。
        如果为2的倍数，扩容只用移位，更高效
 DEFAULT_LOAD_FACTOR       默认负载因子 :扩容的阈值  0.75f
 使用0.75为负载因子的意义：空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。(提升了查询效率，如果为0.5比较浪费内存，如果为1那么过多的会导致hash冲突的频繁以至于链表或红黑树的节点过长影响查询效率)
 TREEIFY_THRESHOLD             链表数量大于等于8时转红黑树
 UNTREEIFY_THRESHOLD       树的数量小于等于6时解体为链表
 size：实际元素的数量
 threshold     map 扩容后的容量    只有当size > threshold * DEFAULT_LOAD_FACTOR才会发生扩容操作
 数据结构：
 数组+单向链表Node/ 红黑树TreeNode
 链表的插入方式：采用尾插法，单向链表是每个节点存储下一个节点的信息，当节点的下一个节点为空时，就将该节点赋值给下一个节点
 put()流程、扩容 
 1、将元素的hash & (length - 1)  判断元素会放到数组的哪个位置
 2、如果该位置没有元素，就直接创建一个node 放入该数组
       如果该位置有元素且为红黑树，就放入红黑树
       否则即为链表，并通过尾插法往元素后追加元素。如果元素大于等于8个了就进行树化
 3、元素数量自增，判断元素是否超过阈值。超过则进行扩容
 扩容：
 1、将原来的容量左移一位
 2、对原来的元素进行操作，迭代Node数组
 如果只有一个元素。就用它的hash值从新计算位置
 如果为红黑树
 否则为链表，将链表的元素分为高低位（hash &  oldLength !=0)，低位进行分类，低位放到原来位置，高位放到原来位置 + oldLength
 get()
 1、计算key的hash值，找在数组哪个位置
 2、判断节点类型
 如果为红黑树
 否则，一直迭代找，只到找到hash值相等,且元素相等为止
 remove()
 步骤基本和前面一致。记录被删除元素的前一个节点，然后将它的next 指向 被删除元素的next
 entrySet(), 会返回一个Set<Entry>集合，内部是将Node数组的元素以及链表的元素迭代实现
